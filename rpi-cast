#!/usr/bin/env bash
set -euo pipefail

trap 'jobs -p | xargs kill' EXIT

DEVICE_NAME=${DEVICE_NAME:-}
LOOPBACK_SINK=${LOOPBACK_SINK:-alsa_output}
VOLUME_THRESHOLD=${VOLUME_THRESHOLD:-0.005}
SILENCE_TIMEOUT=${SILENCE_TIMEOUT:-300}
HIFIBERRY_OVERLAY=${HIFIBERRY_OVERLAY:-}

# Set up HiFiBerry devices
# @link https://www.hifiberry.com/docs/software/configuring-linux-3-18-x/
hifiberry() {
	if [[ "${HIFIBERRY_OVERLAY}" == "" ]]; then
		return
	fi

	sudo sed -i 's/^dtparam=audio=on/# dtparam=audio=on/' /boot/config.txt
	sudo sed -i '/^dtoverlay=vc4-kms-v3d/d' /boot/config.txt
	sudo sed -i '1 i\dtoverlay=vc4-kms-v3d,audio=off' /boot/config.txt

	sudo sed -i '/^dtoverlay=hifiberry/d' /boot/config.txt
	sudo sed -i "1 i\dtoverlay=${HIFIBERRY_OVERLAY}" /boot/config.txt

	sudo tee /etc/asound.conf > /dev/null <<- EOF
	pcm.!default {
	  type hw card 0
	}
	ctl.!default {
	  type hw card 0
	}
	EOF
	if [[ -f ~/.asound.conf ]]; then
		rm ~/.asound.conf
	fi
}

# apt update singleton alias
UPDATED=false
update() {
	if [[ "${UPDATED}" == "false" ]]; then
		echo "Updating remote packages ..."
		sudo apt update > /dev/null || return 0
		UPDATED=true
	fi
}

# apt install alias
install() {
	update
	echo "Installing $* ..."
	sudo apt -y install "$@" > /dev/null
}

# go get alias
go_install() {
	[[ ! -x "$(command -v go)" ]] && install golang-go
	echo "Installing $1 ..."
	go get -u "$1"
}

DEVICE_KEYWORDS="All
Every
Entire
Full"
device_match() {
	for KEYWORD in ${DEVICE_KEYWORDS}; do
		while IFS= read -r DEVICE; do
			if echo "${DEVICE}" | grep --ignore-case "${KEYWORD}" &> /dev/null; then
				echo "${DEVICE}"
				return
			fi
		done <<< "$1"
	done
}
get_device() {
	CHROMECAST_LS=$(go-chromecast ls | ansi2txt | grep --invert-match '^error')
	CHROMECAST_GROUPS=$(echo "${CHROMECAST_LS}" | grep "Google Cast Group" | sed 's/.*device_name="\([^"]\+\)".*/\1/g')
	CHROMECAST_DEVICES=$(echo "${CHROMECAST_LS}" | grep --invert-match "Google Cast Group" | sed 's/.*device_name="\([^"]\+\)".*/\1/g')

	# Cast to a preferred group
	GROUP_DEVICE=$(device_match "${CHROMECAST_GROUPS}")
	if [[ "${GROUP_DEVICE}" != "" ]]; then
		echo "${GROUP_DEVICE}"
		return
	fi

	# Cast to a preferred device
	SINGLE_DEVICE=$(device_match "${CHROMECAST_DEVICES}")
	if [[ "${SINGLE_DEVICE}" != "" ]]; then
		echo "${SINGLE_DEVICE}"
		return
	fi

	# Cast to the first group
	GROUP_DEVICE=$(echo "${CHROMECAST_GROUPS}" | head -1)
	if [[ "${GROUP_DEVICE}" != "" ]]; then
		echo "${GROUP_DEVICE}"
		return
	fi

	# Cast to the first device 
	SINGLE_DEVICE=$(echo "${CHROMECAST_DEVICES}" | head -1)
	if [[ "${SINGLE_DEVICE}" != "" ]]; then
		echo "${SINGLE_DEVICE}"
		return
	fi
}

# Add a PulseAudio loopback if it doesn't already eixst
# @param {string} $1 PulseAudio sink name
loopback() {
	printf "Finding '%s' PulseAudio sink ... " "$1"
	SINK=""
	while [[ "${SINK}" == "" ]]; do
		SINK=$(pactl list short sinks | (grep "$1" || true) | head -1 | awk '{print $1}')
	done
	echo "#${SINK}"

	if [[ "$(pactl list short modules | grep module-loopback | grep "sink=${SINK}")" == "" ]]; then
		printf "Adding loopback for sink #%s ... " "${SINK}"
		pactl load-module module-loopback latency_msec=1 sink="${SINK}" > /dev/null
		echo "done"
	fi
}

# Start mkchromecast and add a loopback for it
start() {
	echo "Casting to '${DEVICE_NAME}' ..."
	mkchromecast --encoder-backend ffmpeg --codec wav --sample-rate 192000 ${DEVICE_NAME:+-n "${DEVICE_NAME}"} &> /dev/null &
	loopback Mkchromecast
	echo "Waiting for cast to start ..."
	while ! is_playing; do
		sleep 1s
	done
	echo ""
}

# Stop mkchromecast if it's running
stop() {
	if pgrep mkchromecast &> /dev/null; then
		echo "Stopping cast ..."
		killall --wait --quiet mkchromecast
		echo ""
	fi
}

# Return if the Chromecast is playing
is_playing() {
	go-chromecast status --device-name "${DEVICE_NAME}" | grep -E "PLAYING|BUFFERING" &> /dev/null
	return $?
}

# Get the peak input volume
# @param {number} $1 Seconds to record to determine peak volume
volume() {
	rec -n stat trim 0 "${1:-1}" 2>&1 | grep 'amplitude' | grep --ignore-case 'RMS' | cut -d ':' -f 2 | xargs
}


##### Dependencies #####

hifiberry

[[ ! -x "$(command -v pactl)" ]] && install pulseaudio-utils
[[ ! -x "$(command -v rec)" ]] && install sox
[[ ! -x "$(command -v mkchromecast)" ]] && install mkchromecast
[[ ! -x "$(command -v ffmpeg)" ]] && install ffmpeg
export GOPATH=$(go env GOPATH)
export GOPATH=${GOPATH:-$(find /home type -d -name "go" 2> /dev/null | head -1)}
PATH=$PATH:${GOPATH}/bin
[[ ! -x "$(command -v go-chromecast)" ]] && go_install github.com/vishen/go-chromecast
[[ ! -x "$(command -v ansi2txt)" ]] && install colorized-logs

##### Main program #####

DEVICE_NAME=${DEVICE_NAME:-$(get_device)}

loopback "${LOOPBACK_SINK}"
echo ""

stop
while true; do
	echo "Waiting for input ..."
	while (( $(echo "$(volume 2) < ${VOLUME_THRESHOLD}" | bc -l) )); do
		sleep 1
	done

	start

	SILENCE_DURATION=0
	while true; do
		if (( $(echo "$(volume 5) < ${VOLUME_THRESHOLD}" | bc -l) )); then
			SILENCE_DURATION=$((SILENCE_DURATION+5))
		else
			SILENCE_DURATION=0
		fi
		if [[ ${SILENCE_DURATION} -ge ${SILENCE_TIMEOUT} ]]; then
			echo "Input stopped"
			break
		fi

		if ! is_playing; then
			echo "Chromecast stopped"
			break
		fi
		sleep 1
	done
	stop
done
